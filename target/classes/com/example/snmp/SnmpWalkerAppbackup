package com.example.snmp;

import org.snmp4j.Snmp;
import org.snmp4j.TransportMapping;
import org.snmp4j.event.ResponseEvent;
import org.snmp4j.mp.SnmpConstants;
import org.snmp4j.smi.*;
import org.snmp4j.transport.DefaultUdpTransportMapping;
import org.snmp4j.util.DefaultPDUFactory;
import org.snmp4j.util.TreeEvent;
import org.snmp4j.util.TreeUtils;
import org.snmp4j.CommunityTarget;
import org.snmp4j.PDU;

import java.sql.Timestamp;

import java.time.format.DateTimeFormatter;
import java.time.format.DateTimeParseException;
import java.io.IOException;
// import java.security.Timestamp;
import java.time.LocalDateTime;
import java.time.OffsetDateTime;
import java.time.ZoneOffset;
import java.util.ArrayList;
import java.util.List;

//for logging
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class SnmpWalkerApp {

    // Global instance
    private static final Logger logger = LoggerFactory.getLogger(App.class);

    public static void main(String[] args) {
        Node testNode = new Node();
        testNode.setIp("10.28.151.251"); // Set your device IP here Sudhara type 12
        // testNode.setIp("10.28.161.242");//Hetauda 18
        // testNode.setIp("10.41.44.19");//sundhara huawei type 9
        // testNode.setIp("10.28.154.218"); // charikot type 17
        testNode.setSnmpcommunity("public"); // SNMP community string
        // String columnRootOid= "1.3.6.1.4.1.3902.1082.500.20.2.1.2.1.3"; // type 18
        // hetauda
        // String columnRootOid = "1.3.6.1.4.1.3902.1012.3.28.1.1.5"; // Replace with
        // desired OID type 12 and 17 sn
        String columnRootOid = "1.3.6.1.4.1.3902.1012.3.28.1.1.2"; // descriptio type
        // 17 and 12
        // String columnRootOid="1.3.6.1.4.1.3902.1012.3.28.2.1.4"; //status 17 and 12
        // String columnRootOid="1.3.6.1.4.1.3902.1082.500.20.2.2.2.1.10";//onu rx power
        // 1.3.6.1.4.1.3902.1082.500.20.2.2.2.1.10.285279245
        // String columnRootOid = "1.3.6.1.4.1.3902.1012.3.28.2.1.5"; // for onu last on
        // date time type 12 and 17
        // String columnRootOid="1.3.6.1.4.1.3902.1082.500.10.2.3.8.1.5"; //18 onu last
        // online
        // String columnRootOid="1.3.6.1.4.1.2011.6.128.1.1.2.46.1.22"; //type 9 onu
        // last online

        sendSnmpWalkAllOnus(testNode, columnRootOid);
    }

    public void scanOnuSerialAllNode(List<Node> nodes, Dao dao) {

    }

    private static void sendSnmpWalkAllOnus(Node node, String columnRootOid) {

        HelperClass hc = new HelperClass();
        List<OnuSerialWithOidClass> resultOnuSerial = new ArrayList<>();
        long startTime = System.currentTimeMillis();
        int counter = 0;

        TransportMapping<UdpAddress> transport = null;
        Snmp snmp = null;

        try {
            transport = new DefaultUdpTransportMapping();
            transport.listen();

            snmp = new Snmp(transport);

            CommunityTarget target = hc.getCommunityTarget(node);
            OID rootOID = new OID(columnRootOid);
            OID rootOIDOnuLastOnline = new OID("1.3.6.1.4.1.3902.1012.3.28.2.1.5");
            OID rootOIDSerial = new OID("1.3.6.1.4.1.3902.1012.3.28.1.1.5");

            System.out.println("Starting SNMP walk on " + node.getIp() + " for OID " + columnRootOid);

            TreeUtils treeUtils = new TreeUtils(snmp, new DefaultPDUFactory());
            List<TreeEvent> events = treeUtils.getSubtree(target, rootOID);
            List<TreeEvent> eventsLastOn = treeUtils.getSubtree(target, rootOIDOnuLastOnline);
            List<TreeEvent> eventsOnuSerial = treeUtils.getSubtree(target, rootOIDSerial);

            if (events == null || events.isEmpty()) {
                System.err.println("No SNMP response received from " + node.getIp());
                logger.info("No SNMP response received from " + node.getIp());
            } else {
                int i = 0;
                TreeEvent eventOnuLastOn = null;
                TreeEvent eventOnuSerial = null;
                for (TreeEvent event : events) {
                    if (event == null || event.isError()) {
                        System.err.println("SNMP error from " + node.getIp() + ": " + event.getErrorMessage());
                        continue;
                    }

                    eventOnuLastOn = eventsLastOn.get(i);
                    eventOnuSerial = eventsOnuSerial.get(i);

                    VariableBinding[] vbs = event.getVariableBindings();

                    VariableBinding[] vbsOnuLastOn = eventOnuLastOn.getVariableBindings();
                    VariableBinding[] vbsOnuSerial = eventOnuSerial.getVariableBindings();
                    if (vbs == null)
                        continue;

                    int j = 0;
                    VariableBinding vbOnuLastOn = null;
                    VariableBinding vbOnuSerial = null;

                    for (VariableBinding vb : vbs) {
                        vbOnuLastOn = vbsOnuLastOn[j];
                        vbOnuSerial = vbsOnuSerial[j];
                        String rawValue = vb.getVariable().toString();
                        String rawValueOnuLastOn = vbOnuLastOn.getVariable().toString();
                        String rawValueOnuSerial = vbOnuSerial.getVariable().toString();
                        // String formattedValue = macToCustomFormat(rawValue);
                        // System.out.println(++counter + " : " + vb.getOid() + " = " + formattedValue);
                        OnuSerialWithOidClass onuSerialWithOidClass = new OnuSerialWithOidClass();
                        OnuSerial onuSerial = new OnuSerial();
                        onuSerial.setName(rawValue);
                        onuSerial.setSerial(macToCustomFormat(rawValueOnuSerial));
                        onuSerial.setOnuLastOnline(Timestamp.valueOf(hc.parseSnmpDate(rawValueOnuLastOn)));
                        onuSerialWithOidClass.setOnuSerial(onuSerial);
                        onuSerialWithOidClass.setOidOnuSerial(vbOnuSerial.getVariable().toString());

                        resultOnuSerial.add(onuSerialWithOidClass);

                        ++counter;
                        System.out.println(counter + " : " + vb.getOid() + " = " + rawValue);
                        System.out.println(
                                counter + " : " + vbOnuSerial.getOid() + " = " + macToCustomFormat(rawValueOnuSerial));
                        System.out
                                .println(counter + " : " + vbOnuLastOn.getOid() + " = "
                                        + parseSnmpDate(rawValueOnuLastOn));
                        // System.out.println(++counter + " : " + vb.getOid() + " = " + rawValue);

                        j++;
                    }
                    i++;

                }
            }

        } catch (IOException e) {
            System.err.println("SNMP walk failed for node " + node.getIp() + ": " + e.getMessage());
            e.printStackTrace();
        } finally {
            try {
                if (snmp != null)
                    snmp.close();
                if (transport != null)
                    transport.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }

        long endTime = System.currentTimeMillis();
        double durationInSeconds = (endTime - startTime) / 1000.0;
        System.out.println("Time taken: " + durationInSeconds + " seconds");
    }

    private static CommunityTarget getCommunityTarget(Node node) {
        CommunityTarget target = new CommunityTarget();
        target.setCommunity(new OctetString(node.getSnmpcommunity()));
        target.setAddress(GenericAddress.parse("udp:" + node.getIp() + "/161"));
        target.setRetries(2);
        target.setTimeout(1500);
        target.setVersion(SnmpConstants.version2c);
        return target;
    }

    private static String macToCustomFormat(String mac) {
        if (mac == null)
            return null;

        StringBuilder sb = new StringBuilder();
        String[] parts = mac.split(":");
        for (String part : parts) {
            int value = Integer.parseInt(part, 16);
            // If printable ASCII A–Z, 0–9, append as char
            if (value >= 48 && value <= 57 || value >= 65 && value <= 90) {
                sb.append((char) value);
            } else {
                // Otherwise append hex string uppercase
                sb.append(String.format("%02X", value));
            }
        }
        return sb.toString();
    }

    public static String parseSnmpDate(String value) {
        value = value.trim();

        // Case 1: Empty or null data (8 or 11 octets of zero)
        if (value.equalsIgnoreCase("N/A") ||
                value.equalsIgnoreCase("00:00:00:00:00:00:00:00") ||
                value.equalsIgnoreCase("00:00:00:00:00:00:00:00:00:00:00")) {
            return "0000-00-00 00:00:00";
        }

        // Case 2: ISO or readable date format
        if (value.matches("\\d{4}-\\d{2}-\\d{2}[ T]\\d{2}:\\d{2}:\\d{2}")) {
            try {
                LocalDateTime dateTime = LocalDateTime.parse(value.replace(" ", "T"));
                return dateTime.format(DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss"));
            } catch (DateTimeParseException e) {
                return "0000-00-00 00:00:00";
            }
        }

        // Case 3: SNMP DateAndTime (8 or 11 bytes hex form)
        if (value.matches("([0-9a-fA-F]{2}:){7,10}[0-9a-fA-F]{2}")) {
            try {
                String[] parts = value.split(":");
                int year = Integer.parseInt(parts[0] + parts[1], 16);
                int month = Integer.parseInt(parts[2], 16);
                int day = Integer.parseInt(parts[3], 16);
                int hour = Integer.parseInt(parts[4], 16);
                int minute = Integer.parseInt(parts[5], 16);
                int second = Integer.parseInt(parts[6], 16);

                LocalDateTime dt = LocalDateTime.of(year, month, day, hour, minute, second);

                // If 11 octets, parse timezone
                if (parts.length >= 11) {
                    String sign = (Integer.parseInt(parts[8], 16) == 0x2D) ? "-" : "+";
                    int tzHour = Integer.parseInt(parts[9], 16);
                    int tzMinute = Integer.parseInt(parts[10], 16);

                    ZoneOffset offset = ZoneOffset.of(sign + String.format("%02d:%02d", tzHour, tzMinute));
                    OffsetDateTime odt = dt.atOffset(offset);
                    return odt.format(DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss"));
                }

                return dt.format(DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss"));
            } catch (Exception e) {
                return "0000-00-00 00:00:00";
            }
        }

        return "0000-00-00 00:00:00";
    }

    public static String parseSnmpDateOldForZteAlone(String value) {
        value = value.trim();

        // Case 1: Empty or null data
        if (value.equalsIgnoreCase("N/A") || value.equalsIgnoreCase("00:00:00:00:00:00:00:00")) {
            return "N/A";
        }

        // Case 2: ISO or readable date format: 2025-08-19 13:44:39
        if (value.matches("\\d{4}-\\d{2}-\\d{2}[ T]\\d{2}:\\d{2}:\\d{2}")) {
            try {
                LocalDateTime dateTime = LocalDateTime.parse(value.replace(" ", "T"));
                return dateTime.format(DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss"));
            } catch (DateTimeParseException e) {
                return "Invalid ISO date";
            }
        }

        // Case 3: Hex format like 07:e9:08:13:0b:2f:23:00
        if (value.matches("([0-9a-fA-F]{2}:){7}[0-9a-fA-F]{2}")) {
            try {
                String[] parts = value.split(":");
                int year = Integer.parseInt(parts[0] + parts[1], 16);
                int month = Integer.parseInt(parts[2], 16);
                int day = Integer.parseInt(parts[3], 16);
                int hour = Integer.parseInt(parts[4], 16);
                int minute = Integer.parseInt(parts[5], 16);
                int second = Integer.parseInt(parts[6], 16);

                // Range check
                if (month < 1 || month > 12 || day < 1 || day > 31 ||
                        hour < 0 || hour > 23 || minute < 0 || minute > 59 || second < 0 || second > 59) {
                    return "Invalid hex timestamp";
                }

                LocalDateTime dt = LocalDateTime.of(year, month, day, hour, minute, second);
                return dt.format(DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss"));

            } catch (Exception e) {
                return "Error parsing hex date";
            }
        }

        return "Unrecognized format";
    }

}
